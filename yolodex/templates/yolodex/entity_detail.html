{% extends "yolodex/base.html" %}

{% load i18n static sekizai_tags %}

{% block title %}{{ object.name }} - {{ realm.name }}{% endblock %}

{% block main %}
  <h2>{{ object.name }}</h2>

  <p>{{ object.data }}</p>
  {{ object.get_absolute_url }}

  <hr/>
  <div id="network-{{ object.pk }}" style="height:400px"></div>

{% addtoblock "js" %}
  <script src="{% static "vendor/sigma/build/sigma.min.js" %}"></script>
  <script src="{% static "vendor/sigma/build/plugins/sigma.parsers.json.min.js" %}"></script>
  <script src="{% static "vendor/sigma/build/plugins/sigma.layout.forceAtlas2.min.js" %}"></script>
  <script>
    // $(window).load(function() {
      var subjectID = "{{ object.id }}";
      sigma.classes.graph.addMethod('neighbors', function(nodeId) {
        var k,
            neighbors = {},
            index = this.allNeighborsIndex[nodeId] || {};

        for (k in index)
          neighbors[k] = this.nodesIndex[k];

        return neighbors;
      });

      sigma.parsers.json( "./graph.json", {
        container: 'network-{{ object.pk }}'
      }, function(s){

        s.settings({
          edgeColor: '#ddd',
          defaultEdgeColor: '#ddd',
          labelSize: "proportional",
          defaultNodeBorderColor: '#fff',
          scalingMode: "outside"
        });

        // We first need to save the original colors of our
        // nodes and edges, like this:
        s.graph.nodes().forEach(function(n) {
          n.x = Math.random();
          n.y = Math.random();
          n.label = n.name;
          if (n.id === subjectID) {
            n.color = 'red';
          } else {
            n.color = n.data.color || '#aaa'
          }
          n.size = 1;
          console.log(n.degree);
          n.originalColor = n.color;
        });
        s.graph.edges().forEach(function(e) {
          e.originalColor = e.color;
        });

        // When a node is clicked, we check for each node
        // if it is a neighbor of the clicked one. If not,
        // we set its color as grey, and else, it takes its
        // original color.
        // We do the same for the edges, and we only keep
        // edges that have both extremities colored.
        s.bind('clickNode', function(e) {
          var nodeId = e.data.node.id,
              toKeep = s.graph.neighbors(nodeId);
          toKeep[nodeId] = e.data.node;

          s.graph.nodes().forEach(function(n) {
            if (toKeep[n.id])
              n.color = n.originalColor;
            else
              n.color = '#00f';
          });

          s.graph.edges().forEach(function(e) {
            if (toKeep[e.source] && toKeep[e.target])
              e.color = e.originalColor;
            else
              e.color = '#00f';
          });

          // Since the data has been modified, we need to
          // call the refresh method to make the colors
          // update effective.
          s.refresh();
        });
        //
        // // When the stage is clicked, we just color each
        // // node and edge with its original color.
        s.bind('clickStage', function(e) {
          s.graph.nodes().forEach(function(n) {
            n.color = n.originalColor;
          });

          s.graph.edges().forEach(function(e) {
            e.color = e.originalColor;
          });

          // Same as in the previous event:
          s.refresh();
        });

        s.refresh();
        s.startForceAtlas2({
          barnesHutOptimize: false
        });
        window.setTimeout(function(){
          s.killForceAtlas2();
        }, 5000);
      });
  </script>
{% endaddtoblock %}

{% endblock %}
